
 <!DOCTYPE HTML>
<html lang="zh">
<head>
  <meta charset="UTF-8">
  
    <title>前端知识点总结（一） | Welkin</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=3, minimum-scale=1">
    
    <meta name="author" content="welkin">
    
    <meta name="description" content="@TOC
一、ES61. let const 和var 的区别a. let和const的区别
let 是变量
const 是常量b. let和const和var 有三点区别


不存在变量提升let 改变了语法行为，它所声明的变量一定要在声明后使用，否则就会报错
暂时性死区如果区块中存在let 和c">
    
    
    
    
    
    <link rel="icon" href="/img/favicon.ico">
    
    
    <link rel="apple-touch-icon" href="/img/pacman.jpg">
    <link rel="apple-touch-icon-precomposed" href="/img/pacman.jpg">
    
    <link rel="stylesheet" href="/css/style.css">
</head>

  <body>
    <header>
      <div>
		
			<div id="imglogo">
				<a href="/"><img src="/img/logo.svg" alt="Welkin" title="Welkin"/></a>
			</div>
			
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="Welkin">Welkin</a></h1>
				<h2 class="blog-motto"></h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="Menu">
			</a></div>
			<nav class="animated">
				<ul>
					
						<li><a href="/">Home</a></li>
					
						<li><a href="/archives">Archives</a></li>
					
					<li>
					
					<form class="search" action="//google.com/search" method="get" accept-charset="utf-8">
						<label>Search</label>
						<input type="text" id="search" name="q" autocomplete="off" maxlength="20" placeholder="Search" />
						<input type="hidden" name="q" value="site:yoursite.com">
					</form>
					
					</li>
				</ul>
			</nav>			
</div>

    </header>
    <div id="container">
      <div id="main" class="post" itemscope itemprop="blogPost">
	<article itemprop="articleBody"> 
		<header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2019/03/15/前端知识点总结（一）.html" title="前端知识点总结（一）" itemprop="url">前端知识点总结（一）</a>
  </h1>
  <p class="article-author">By
    
      <a href="http://yoursite.com" title="welkin">welkin</a>
    </p>
  <p class="article-time">
    <time datetime="2019-03-15T10:45:51.000Z" itemprop="datePublished">2019-03-15</time>
    Updated:<time datetime="2019-03-15T10:47:28.861Z" itemprop="dateModified">2019-03-15</time>
    
  </p>
</header>
	<div class="article-content">
		
		
		<div id="toc" class="toc-article">
			<strong class="toc-title">Contents</strong>
		<ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#一、ES6"><span class="toc-number">1.</span> <span class="toc-text">一、ES6</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-let-const-和var-的区别"><span class="toc-number">1.0.1.</span> <span class="toc-text">1. let const 和var 的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#a-let和const的区别"><span class="toc-number">1.0.1.0.1.</span> <span class="toc-text">a. let和const的区别</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#b-let和const和var-有三点区别"><span class="toc-number">1.0.1.0.2.</span> <span class="toc-text">b. let和const和var 有三点区别</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-promise"><span class="toc-number">1.0.2.</span> <span class="toc-text">2. promise</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#a-promise是什么？"><span class="toc-number">1.0.2.0.1.</span> <span class="toc-text">a. promise是什么？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#b-promise的特点"><span class="toc-number">1.0.2.0.2.</span> <span class="toc-text">b. promise的特点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#c-promise-的作用"><span class="toc-number">1.0.2.0.3.</span> <span class="toc-text">c. promise 的作用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#d-promise-的缺点、"><span class="toc-number">1.0.2.0.4.</span> <span class="toc-text">d. promise 的缺点、</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#如果某些事件不断的反复发生，使用stream-模式nodejs-org-api-stream-html，是比部署promise更好的选择"><span class="toc-number">1.0.2.0.4.1.</span> <span class="toc-text">如果某些事件不断的反复发生，使用stream 模式nodejs.org/api/stream.html，是比部署promise更好的选择</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#e-promise基本用法"><span class="toc-number">1.0.2.0.5.</span> <span class="toc-text">e. promise基本用法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#f-then方法指定resolved-和-rejected-状态的回调函数"><span class="toc-number">1.0.2.0.6.</span> <span class="toc-text">f. .then方法指定resolved 和 rejected 状态的回调函数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-箭头函数"><span class="toc-number">1.0.3.</span> <span class="toc-text">3. 箭头函数</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#箭头函数的缺点"><span class="toc-number">1.0.3.0.1.</span> <span class="toc-text">箭头函数的缺点</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#二、vue"><span class="toc-number">2.</span> <span class="toc-text">二、vue</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-计算属性"><span class="toc-number">2.0.1.</span> <span class="toc-text">1. 计算属性</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#a-为什么会有计算属性"><span class="toc-number">2.0.1.0.1.</span> <span class="toc-text">a. 为什么会有计算属性</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#b-如何使用计算属性"><span class="toc-number">2.0.1.0.2.</span> <span class="toc-text">b. 如何使用计算属性</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#c-计算属性缓存和方法（method）的对比"><span class="toc-number">2.0.1.0.3.</span> <span class="toc-text">c. 计算属性缓存和方法（method）的对比</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#每当触发重新渲染时，调用方法将总会再次执行函数。"><span class="toc-number">2.0.1.0.3.1.</span> <span class="toc-text">每当触发重新渲染时，调用方法将总会再次执行函数。</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#d-计算属性和侦听属性（watch）的对比"><span class="toc-number">2.0.1.0.4.</span> <span class="toc-text">d. 计算属性和侦听属性（watch）的对比</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#e-计算属性的setter"><span class="toc-number">2.0.1.0.5.</span> <span class="toc-text">e. 计算属性的setter</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-自定义指令"><span class="toc-number">2.0.2.</span> <span class="toc-text">2. 自定义指令</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#a-为什么会有自定义指令"><span class="toc-number">2.0.2.0.1.</span> <span class="toc-text">a. 为什么会有自定义指令</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#b-怎么使用自定义指令？"><span class="toc-number">2.0.2.0.2.</span> <span class="toc-text">b. 怎么使用自定义指令？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-父子组件"><span class="toc-number">2.0.3.</span> <span class="toc-text">3. 父子组件</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#a-父组件通过-Prop向子组件传递数据"><span class="toc-number">2.0.3.0.1.</span> <span class="toc-text">a. 父组件通过 Prop向子组件传递数据</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#b-子组件往父组件传值（-emit）"><span class="toc-number">2.0.3.0.2.</span> <span class="toc-text">b. 子组件往父组件传值（$emit）</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#三、http"><span class="toc-number">3.</span> <span class="toc-text">三、http</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-get和post在url协议上的区别"><span class="toc-number">3.0.1.</span> <span class="toc-text">1. get和post在url协议上的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-get请求和post请求的区别"><span class="toc-number">3.0.2.</span> <span class="toc-text">2. get请求和post请求的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-跨域"><span class="toc-number">3.0.3.</span> <span class="toc-text">3. 跨域</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-什么是跨域"><span class="toc-number">3.0.3.0.1.</span> <span class="toc-text">1. 什么是跨域</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-为什么会有跨域"><span class="toc-number">3.0.3.0.2.</span> <span class="toc-text">2. 为什么会有跨域</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-常见的跨域场景"><span class="toc-number">3.0.3.0.3.</span> <span class="toc-text">3. 常见的跨域场景</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-跨域的解决方案"><span class="toc-number">3.0.3.0.4.</span> <span class="toc-text">4. 跨域的解决方案</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#a-jsonp"><span class="toc-number">3.0.3.0.4.1.</span> <span class="toc-text">a. jsonp</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#虽然这种方式非常好用，但是一个最大的缺陷是，只能够实现get请求"><span class="toc-number">3.0.3.0.5.</span> <span class="toc-text">虽然这种方式非常好用，但是一个最大的缺陷是，只能够实现get请求</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#b-cors"><span class="toc-number">3.0.3.0.6.</span> <span class="toc-text">b. cors</span></a></li></ol></li></ol></li></ol></li></ol></li></ol>
		</div>
		
		<p>@<a href="文章目录">TOC</a></p>
<h1 id="一、ES6"><a href="#一、ES6" class="headerlink" title="一、ES6"></a>一、ES6</h1><h3 id="1-let-const-和var-的区别"><a href="#1-let-const-和var-的区别" class="headerlink" title="1. let const 和var 的区别"></a>1. let const 和var 的区别</h3><h5 id="a-let和const的区别"><a href="#a-let和const的区别" class="headerlink" title="a. let和const的区别"></a>a. let和const的区别</h5><ul>
<li>let 是变量</li>
<li>const 是常量<h5 id="b-let和const和var-有三点区别"><a href="#b-let和const和var-有三点区别" class="headerlink" title="b. let和const和var 有三点区别"></a>b. let和const和var 有三点区别</h5></li>
</ul>
<ol>
<li>不存在变量提升<br>let 改变了语法行为，它所声明的变量一定要在声明后使用，否则就会报错</li>
<li>暂时性死区<br>如果区块中存在let 和const命令，则这个区块对这些命令声明的变量从一开始就形成封闭作用域，只要在声明之前就使用这些变量，就会报错<br><strong>本质</strong>：只要进入当前作用域，所要使用的变量就已经存在，但是不可获取，只有等到声明变量的那一行代码出现时，才可以获取和使用该变量</li>
<li>不允许重复声明</li>
</ol>
<h3 id="2-promise"><a href="#2-promise" class="headerlink" title="2. promise"></a>2. promise</h3><h5 id="a-promise是什么？"><a href="#a-promise是什么？" class="headerlink" title="a. promise是什么？"></a>a. promise是什么？</h5><p>简单来说，就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。<br>从语法来说，promise是一个对象，从他可以获取异步操作的结果。<br>promise提供统一的API，各种异步操作都可以用同样的方法进行处理。</p>
<h5 id="b-promise的特点"><a href="#b-promise的特点" class="headerlink" title="b. promise的特点"></a>b. promise的特点</h5><ol>
<li>对象的状态不受外界影响。<br>promise 对象代表一个异步操作，有以下3种状态：<ul>
<li>pending（进行中）</li>
<li>fulfilled（已成功）</li>
<li>rejected（已失败）</li>
</ul>
</li>
</ol>
<p>只有异步操作的结果可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。<br>promise的汉语意思是“承诺”，表示其他手段无法改变</p>
<ol>
<li>一旦状态改变就不会再变，任何时候都可以得到这个结果<br>promise对象的状态改变只有两种可能：<ol>
<li>pending–&gt;fulfilled（从进行中变为已成功）</li>
<li>pending–&gt;rejected（从进行中变为已失败）</li>
</ol>
</li>
</ol>
<p>只要这两种情况发生，状态就凝固了，不会再改变，一直保持这个结果，这时候就被称为resolved（已定型）。就算改变已经发生，再对promise 对象添加回调函数，也会立即得到这个结果。<br>这与事件（event）完全不同，如果错过了它，再去监听是得不到的。</p>
<h5 id="c-promise-的作用"><a href="#c-promise-的作用" class="headerlink" title="c. promise 的作用"></a>c. promise 的作用</h5><p>可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。此外，promise 对象提供了统一的接口，使得控制异步操作更加容易。</p>
<h5 id="d-promise-的缺点、"><a href="#d-promise-的缺点、" class="headerlink" title="d. promise 的缺点、"></a>d. promise 的缺点、</h5><ol>
<li>无法取消promise， 一旦新建它就会立即执行，无法中途取消。</li>
<li>如果不设置回调函数，promise 内部抛出的错误不会反应到外部</li>
<li>当处于 pending 状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）</li>
</ol>
<h6 id="如果某些事件不断的反复发生，使用stream-模式nodejs-org-api-stream-html，是比部署promise更好的选择"><a href="#如果某些事件不断的反复发生，使用stream-模式nodejs-org-api-stream-html，是比部署promise更好的选择" class="headerlink" title="如果某些事件不断的反复发生，使用stream 模式nodejs.org/api/stream.html，是比部署promise更好的选择"></a>如果某些事件不断的反复发生，使用stream 模式<a href="nodejs.org/api/stream.html">nodejs.org/api/stream.html</a>，是比部署promise更好的选择</h6><h5 id="e-promise基本用法"><a href="#e-promise基本用法" class="headerlink" title="e. promise基本用法"></a>e. promise基本用法</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> promise = <span class="keyword">new</span> promise(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">	<span class="comment">// some code</span></span><br><span class="line">	<span class="keyword">if</span>(<span class="comment">/*异步操作成功*/</span>)&#123;</span><br><span class="line">		resolve(value); </span><br><span class="line">		<span class="comment">//将对象的状态从“未完成”变为“成功”，在异步操作成功时调用，并将异步操作的结果作为参数传递出去</span></span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		reject(error)</span><br><span class="line">		<span class="comment">//将对象的状态由“未完成”变为“失败”，在异步操作失败时调用，并将异步操作报出的错误作为参数传递出去</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>promise构造函数接受一个函数作为参数，该函数的两个参数分别是resolve 和 reject。 他们是两个函数。由js提供，不用自己部署。</p>
<h5 id="f-then方法指定resolved-和-rejected-状态的回调函数"><a href="#f-then方法指定resolved-和-rejected-状态的回调函数" class="headerlink" title="f. .then方法指定resolved 和 rejected 状态的回调函数"></a>f. .then方法指定resolved 和 rejected 状态的回调函数</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">promise.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">	<span class="comment">//success</span></span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">error</span>)</span>&#123;</span><br><span class="line">	<span class="comment">//failure</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>then 方法可以接受两个回调函数作为参数。</p>
<ol>
<li>第一个回调函数是 promise 对象的状态变为 resolved 时调用</li>
<li>第一个回调函数是 promise 对象的状态变为 rejected 时调用（这个函数是可选的，不一定要提供。）<br>两个函数都接受 promise 对象传出的值作为参数。</li>
</ol>
<h3 id="3-箭头函数"><a href="#3-箭头函数" class="headerlink" title="3. 箭头函数"></a>3. 箭头函数</h3><ol>
<li><p>允许使用箭头定义函数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="params">v</span> =&gt;</span> v</span><br><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span>(<span class="params">v</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用圆括号代表参数部分</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="params">()</span> =&gt;</span> <span class="number">5</span>;</span><br><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">5</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sum = <span class="function">(<span class="params">num1, num2</span>) =&gt;</span> num1 + num2</span><br><span class="line"><span class="keyword">var</span> sum = <span class="function"><span class="keyword">function</span>(<span class="params">num1, num2</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> num1 + num2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果箭头函数的代码块多于一条语句，就要使用大括号将其括起来，并使用return 返回</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sum = <span class="function">(<span class="params">num1, num2</span>) =&gt;</span> num1 + num2</span><br><span class="line"><span class="keyword">var</span> sum = <span class="function"><span class="keyword">function</span>(<span class="params">num1, num2</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> num1 + num2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果箭头函数直接返回一个对象，必须在对象外面加上括号</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> getTempItem = <span class="function"><span class="params">id</span> =&gt;</span> (&#123;<span class="attr">id</span>: id,<span class="attr">name</span>:<span class="string">"Temp"</span>&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>箭头函数可以与变量解构结合使用</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> full = <span class="function">(<span class="params">&#123;first, last&#125;</span>) =&gt;</span> first + <span class="string">''</span> + last</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">full</span>(<span class="params">person</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> person.first + <span class="string">''</span> + person.last</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>简化回调函数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].map(<span class="function"><span class="keyword">function</span> (<span class="params">x</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x*x;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 箭头函数</span></span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].map(<span class="function"><span class="params">x</span> =&gt;</span> x*x)</span><br></pre></td></tr></table></figure>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//even</span></span><br><span class="line"><span class="keyword">const</span> isEven = <span class="function"><span class="params">n</span> =&gt;</span> n%<span class="number">2</span>==<span class="number">0</span>;</span><br><span class="line"><span class="comment">//square</span></span><br><span class="line"><span class="keyword">const</span> quare = <span class="function"><span class="params">n</span> =&gt;</span> n*n</span><br></pre></td></tr></table></figure>
<hr>
<p><strong>注意事项</strong></p>
<ul>
<li>箭头函数体内的this 对象就是定义时所在的对象，而不是使用时所在的对象<br>this对象的指向是可变的，但在箭头函数中它是固定的<br>箭头函数可以让this 指向固定化，有利于封装回调函数</li>
</ul>
<p><strong>this指向固定化原因</strong><br>this指向固定化并不是因为箭头函数内部由绑定this的机制，实际原因是箭头函数根本没有this，导致内部的this 就是外层代码块的this（正是因为没有this 所以不能用作构造函数）</p>
<p>由于箭头函数没有自己的this，当然不能用call(),apply(),bind()这些方法改变this 的指向<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	setTimeout(<span class="function"><span class="params">()</span> =&gt;</span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">'id:'</span>, <span class="keyword">this</span>.id);</span><br><span class="line">	&#125;, <span class="number">100</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> id = <span class="number">21</span>;</span><br><span class="line">foo.call(&#123;<span class="attr">id</span>:<span class="number">42</span>&#125;)</span><br><span class="line"><span class="comment">//id:42</span></span><br></pre></td></tr></table></figure></p>
<p>如果是普通函数，执行时this 应该指向全局对象window，即应该输出21<br>箭头函数导致this 总是指向函数定义生效时所在的对象</p>
<hr>
<h5 id="箭头函数的缺点"><a href="#箭头函数的缺点" class="headerlink" title="箭头函数的缺点"></a>箭头函数的缺点</h5><ul>
<li>不可以当做构造函数。也就是说，不可以使用new命令，否则就会抛出一个错误</li>
<li>不可以使用arguments 对象，该对象在函数体内不存在。如果要使用，可以使用rest 参数代替</li>
<li>不可以使用 yield 命令，因此箭头函数不能用作Generator 函数</li>
</ul>
<hr>
<h1 id="二、vue"><a href="#二、vue" class="headerlink" title="二、vue"></a>二、vue</h1><h3 id="1-计算属性"><a href="#1-计算属性" class="headerlink" title="1. 计算属性"></a>1. 计算属性</h3><h5 id="a-为什么会有计算属性"><a href="#a-为什么会有计算属性" class="headerlink" title="a. 为什么会有计算属性"></a>a. 为什么会有计算属性</h5><p>减少模板中的复杂逻辑，容易维护模板</p>
<h5 id="b-如何使用计算属性"><a href="#b-如何使用计算属性" class="headerlink" title="b. 如何使用计算属性"></a>b. 如何使用计算属性</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"example"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>Original message: "&#123;&#123; message &#125;&#125;"<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>Computed reversed message: "&#123;&#123; reversedMessage &#125;&#125;"<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#example'</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    message: <span class="string">'Hello'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  computed: &#123;</span><br><span class="line">    <span class="comment">// 计算属性的 getter</span></span><br><span class="line">    reversedMessage: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="comment">// `this` 指向 vm 实例</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.message.split(<span class="string">''</span>).reverse().join(<span class="string">''</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>结果<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Original message: <span class="string">"Hello"</span></span><br><span class="line">Computed reversed message: <span class="string">"olleH"</span></span><br></pre></td></tr></table></figure></p>
<p>这里我们声明了一个计算属性 reversedMessage。我们提供的函数将用作属性 vm.reversedMessage 的 getter 函数：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(vm.reversedMessage) <span class="comment">// =&gt; 'olleH'</span></span><br><span class="line">vm.message = <span class="string">'Goodbye'</span></span><br><span class="line"><span class="built_in">console</span>.log(vm.reversedMessage) <span class="comment">// =&gt; 'eybdooG'</span></span><br></pre></td></tr></table></figure></p>
<p>你可以打开浏览器的控制台，自行修改例子中的 vm。vm.reversedMessage 的值始终取决于 vm.message 的值。<br>你可以像绑定普通属性一样在模板中绑定计算属性。Vue 知道 vm.reversedMessage 依赖于 vm.message，因此当 vm.message 发生改变时，所有依赖 vm.reversedMessage 的绑定也会更新。而且最妙的是我们已经以声明的方式创建了这种依赖关系：计算属性的 getter 函数是没有副作用 (side effect) 的，这使它更易于测试和理解。</p>
<h5 id="c-计算属性缓存和方法（method）的对比"><a href="#c-计算属性缓存和方法（method）的对比" class="headerlink" title="c. 计算属性缓存和方法（method）的对比"></a>c. 计算属性缓存和方法（method）的对比</h5><p>我们可以将同一函数定义为一个方法而不是一个计算属性。两种方式的最终结果确实是完全相同的。然而，不同的是计算属性是基于它们的依赖进行缓存的。只在相关依赖发生改变时它们才会重新求值。这就意味着只要 message 还没有发生改变，多次访问 reversedMessage 计算属性会立即返回之前的计算结果，而不必再次执行函数。</p>
<h6 id="每当触发重新渲染时，调用方法将总会再次执行函数。"><a href="#每当触发重新渲染时，调用方法将总会再次执行函数。" class="headerlink" title="每当触发重新渲染时，调用方法将总会再次执行函数。"></a>每当触发重新渲染时，调用方法将总会再次执行函数。</h6><p>我们为什么需要缓存？假设我们有一个性能开销比较大的计算属性 A，它需要遍历一个巨大的数组并做大量的计算。然后我们可能有其他的计算属性依赖于 A 。如果没有缓存，我们将不可避免的多次执行 A 的 getter！如果你不希望有缓存，请用方法来替代。</p>
<h5 id="d-计算属性和侦听属性（watch）的对比"><a href="#d-计算属性和侦听属性（watch）的对比" class="headerlink" title="d. 计算属性和侦听属性（watch）的对比"></a>d. 计算属性和侦听属性（watch）的对比</h5><p>Vue 提供了一种更通用的方式来观察和响应 Vue 实例上的数据变动：侦听属性。当你有一些数据需要随着其它数据变动而变动时，你很容易滥用 watch——特别是如果你之前使用过 AngularJS。然而，通常更好的做法是使用计算属性而不是命令式的 watch 回调。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"demo"</span>&gt;</span>&#123;&#123; fullName &#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>watch:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#demo'</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    firstName: <span class="string">'Foo'</span>,</span><br><span class="line">    lastName: <span class="string">'Bar'</span>,</span><br><span class="line">    fullName: <span class="string">'Foo Bar'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  watch: &#123;</span><br><span class="line">    firstName: <span class="function"><span class="keyword">function</span> (<span class="params">val</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.fullName = val + <span class="string">' '</span> + <span class="keyword">this</span>.lastName</span><br><span class="line">    &#125;,</span><br><span class="line">    lastName: <span class="function"><span class="keyword">function</span> (<span class="params">val</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.fullName = <span class="keyword">this</span>.firstName + <span class="string">' '</span> + val</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>计算属性：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#demo'</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    firstName: <span class="string">'Foo'</span>,</span><br><span class="line">    lastName: <span class="string">'Bar'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  computed: &#123;</span><br><span class="line">    fullName: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.firstName + <span class="string">' '</span> + <span class="keyword">this</span>.lastName</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<h5 id="e-计算属性的setter"><a href="#e-计算属性的setter" class="headerlink" title="e. 计算属性的setter"></a>e. 计算属性的setter</h5><p>计算属性默认只有 getter ，不过在需要时你也可以提供一个 setter ：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line">computed: &#123;</span><br><span class="line">  fullName: &#123;</span><br><span class="line">    <span class="comment">// getter</span></span><br><span class="line">    get: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.firstName + <span class="string">' '</span> + <span class="keyword">this</span>.lastName</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// setter</span></span><br><span class="line">    set: <span class="function"><span class="keyword">function</span> (<span class="params">newValue</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> names = newValue.split(<span class="string">' '</span>)</span><br><span class="line">      <span class="keyword">this</span>.firstName = names[<span class="number">0</span>]</span><br><span class="line">      <span class="keyword">this</span>.lastName = names[names.length - <span class="number">1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure></p>
<p>现在再运行 vm.fullName = ‘John Doe’ 时，setter 会被调用，vm.firstName 和 vm.lastName 也会相应地被更新。</p>
<h3 id="2-自定义指令"><a href="#2-自定义指令" class="headerlink" title="2. 自定义指令"></a>2. 自定义指令</h3><h5 id="a-为什么会有自定义指令"><a href="#a-为什么会有自定义指令" class="headerlink" title="a. 为什么会有自定义指令"></a>a. 为什么会有自定义指令</h5><p>需要对普通 DOM 元素进行底层操作，这时候就会用到自定义指令</p>
<h5 id="b-怎么使用自定义指令？"><a href="#b-怎么使用自定义指令？" class="headerlink" title="b. 怎么使用自定义指令？"></a>b. 怎么使用自定义指令？</h5><p>例 ： autofocus<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注册一个全局自定义指令 `v-focus`</span></span><br><span class="line">Vue.directive(<span class="string">'focus'</span>, &#123;</span><br><span class="line">  <span class="comment">// 当被绑定的元素插入到 DOM 中时……</span></span><br><span class="line">  inserted: <span class="function"><span class="keyword">function</span> (<span class="params">el</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 聚焦元素</span></span><br><span class="line">    el.focus()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>如果想注册局部指令，组件中也接受一个 directives 的选项：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">directives: &#123;</span><br><span class="line">  focus: &#123;</span><br><span class="line">    <span class="comment">// 指令的定义</span></span><br><span class="line">    inserted: <span class="function"><span class="keyword">function</span> (<span class="params">el</span>) </span>&#123;</span><br><span class="line">      el.focus()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后你可以在模板中任何元素上使用新的 v-focus 属性，如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input v-focus&gt;</span><br></pre></td></tr></table></figure></p>
<h3 id="3-父子组件"><a href="#3-父子组件" class="headerlink" title="3. 父子组件"></a>3. 父子组件</h3><p>原文：<a href="https://segmentfault.com/a/1190000014704088?utm_source=channel-hottest" target="_blank" rel="noopener">https://segmentfault.com/a/1190000014704088?utm_source=channel-hottest</a></p>
<h5 id="a-父组件通过-Prop向子组件传递数据"><a href="#a-父组件通过-Prop向子组件传递数据" class="headerlink" title="a. 父组件通过 Prop向子组件传递数据"></a>a. 父组件通过 Prop向子组件传递数据</h5><ol>
<li>首先父组件通过components引入子组件</li>
<li>如果要传入子组件的值是动态的.可以将该值双向绑定在调用的子组件上</li>
<li>子组件只需要做一件事,那就是通过props接收</li>
</ol>
<p>父组件：<br><img src="https://img-blog.csdnimg.cn/20190315150641942.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1dlbGtpbl9xaW5n,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>子组件：<br><img src="https://img-blog.csdnimg.cn/20190315150656991.png" alt="在这里插入图片描述"></p>
<h5 id="b-子组件往父组件传值（-emit）"><a href="#b-子组件往父组件传值（-emit）" class="headerlink" title="b. 子组件往父组件传值（$emit）"></a>b. 子组件往父组件传值（$emit）</h5><p>可以定义一个事件来触发响应的$emit使父组件可以知道有事件改变,进而接收对应的参数<br>父组件：<br><img src="https://img-blog.csdnimg.cn/20190315152332666.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20190315152442594.png" alt="在这里插入图片描述"><br>子组件：<br>定义一个事件来触发：<br><img src="https://img-blog.csdnimg.cn/20190315152508195.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1dlbGtpbl9xaW5n,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20190315152532392.png" alt="在这里插入图片描述"></p>
<h1 id="三、http"><a href="#三、http" class="headerlink" title="三、http"></a>三、http</h1><h3 id="1-get和post在url协议上的区别"><a href="#1-get和post在url协议上的区别" class="headerlink" title="1. get和post在url协议上的区别"></a>1. get和post在url协议上的区别</h3><p>Http协议定义了很多与服务器交互的方法，最基本的有4种，分别是GET,POST,PUT,DELETE. 一个URL地址用于描述一个网络上的资源，而HTTP中的GET, POST, PUT, DELETE就对应着对这个资源的查，改，增，删4个操作。 我们最常见的就是GET和POST了。<br>GET一般用于获取/查询资源信息，而POST一般用于更新资源信息。</p>
<ol>
<li>GET提交的数据会放在URL之后，以?分割URL和传输数据，参数之间以&amp;相连，如EditPosts.aspx?name=test1&amp;id=123456<br>POST方法是把提交的数据放在HTTP包的Body中.</li>
<li>GET提交的数据大小有限制（因为浏览器对URL的长度有限制），<br>而POST方法提交的数据没有限制.</li>
<li>GET方式需要使用Request.QueryString来取得变量的值，<br>而POST方式通过Request.Form来获取变量的值。</li>
<li>GET方式提交数据，会带来安全问题，比如一个登录页面，通过GET方式提交数据时，用户名和密码将出现在URL上，如果页面可以被缓存或者其他人可以访问这台机器，就可以从历史记录获得该用户的账号和密码.</li>
</ol>
<h3 id="2-get请求和post请求的区别"><a href="#2-get请求和post请求的区别" class="headerlink" title="2. get请求和post请求的区别"></a>2. get请求和post请求的区别</h3><ul>
<li>get<br>一般用来查询操作，url 地址有长度限制，请求的参数都是暴露在url地址当中，如果传递中文参数，需要自己进行编码操作，安全性较低</li>
<li>post<br>请求方式主要用来提交数据，没有数据长度的限制，提交的数据内容存在于http 请求体中，数据不会暴露在url地址中</li>
</ul>
<h3 id="3-跨域"><a href="#3-跨域" class="headerlink" title="3. 跨域"></a>3. 跨域</h3><h5 id="1-什么是跨域"><a href="#1-什么是跨域" class="headerlink" title="1. 什么是跨域"></a>1. 什么是跨域</h5><p>跨域的概念：协议、域名、端口都相同才是同域，否则都是跨域</p>
<h5 id="2-为什么会有跨域"><a href="#2-为什么会有跨域" class="headerlink" title="2. 为什么会有跨域"></a>2. 为什么会有跨域</h5><p>跨域，是指浏览器不能执行其他网站的脚本。它是由浏览器的同源策略造成的，是浏览器对JavaScript实施的安全限制。<br>同源策略限制了以下行为：</p>
<ul>
<li>Cookie、LocalStorage 和 IndexDB 无法读取</li>
<li>DOM 和 JS 对象无法获取</li>
<li>Ajax请求发送不出去</li>
</ul>
<p>出于安全考虑，服务器不允许ajax 跨域获取数据，但是可以跨域获取文件内容。</p>
<h5 id="3-常见的跨域场景"><a href="#3-常见的跨域场景" class="headerlink" title="3. 常见的跨域场景"></a>3. 常见的跨域场景</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">http:<span class="comment">//www.nealyang.cn/index.html 调用   http://www.nealyang.cn/server.php  非跨域</span></span><br><span class="line"></span><br><span class="line">http:<span class="comment">//www.nealyang.cn/index.html 调用   http://www.neal.cn/server.php  跨域,主域不同</span></span><br><span class="line"></span><br><span class="line">http:<span class="comment">//abc.nealyang.cn/index.html 调用   http://def.neal.cn/server.php  跨域,子域名不同</span></span><br><span class="line"></span><br><span class="line">http:<span class="comment">//www.nealyang.cn:8080/index.html 调用   http://www.nealyang.cn/server.php  跨域,端口不同</span></span><br><span class="line"></span><br><span class="line">https:<span class="comment">//www.nealyang.cn/index.html 调用   http://www.nealyang.cn/server.php  跨域,协议不同</span></span><br><span class="line"></span><br><span class="line">localhost   调用 <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> 跨域</span><br></pre></td></tr></table></figure>
<h5 id="4-跨域的解决方案"><a href="#4-跨域的解决方案" class="headerlink" title="4. 跨域的解决方案"></a>4. 跨域的解决方案</h5><p>原文：<a href="https://juejin.im/post/5a2f92c65188253e2470f16d" target="_blank" rel="noopener">https://juejin.im/post/5a2f92c65188253e2470f16d</a></p>
<h6 id="a-jsonp"><a href="#a-jsonp" class="headerlink" title="a. jsonp"></a>a. jsonp</h6><ol>
<li>jsonp 是什么？<br>jsonp 并不是一种数据格式（而json是一种数据格式），jsonp 是用来解决跨域获取数据的一种解决方案。<br>jsonp跨域其实也是JavaScript设计模式中的一种代理模式。</li>
<li>怎么解决的？<br>在html页面中通过相应的标签从不同域名下加载静态资源文件是被浏览器允许的，所以我们可以通过这个“犯罪漏洞”来进行跨域。<br>通过标签的src 属性获取js 文件的js 脚本，该脚本的内容是一个函数调用，参数就是服务器返回的数据，为了处理这些返回的数据，需要事先在页面定义好回调函数，<strong>本质上使用的并不是ajax技术</strong>。</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//原生的实现方式</span></span><br><span class="line"><span class="keyword">let</span> script = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>);</span><br><span class="line">script.src = <span class="string">'http://www.nealyang.cn/login?username=Nealyang&amp;callback=callback'</span>;</span><br><span class="line"><span class="built_in">document</span>.body.appendChild(script);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callback</span>(<span class="params">res</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>当然，jquery也支持jsonp的实现方式<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">    url:<span class="string">'http://www.nealyang.cn/login'</span>,</span><br><span class="line">    type:<span class="string">'GET'</span>,</span><br><span class="line">    dataType:<span class="string">'jsonp'</span>,<span class="comment">//请求方式为jsonp</span></span><br><span class="line">    jsonpCallback:<span class="string">'callback'</span>,</span><br><span class="line">    data:&#123;</span><br><span class="line">        <span class="string">"username"</span>:<span class="string">"Nealyang"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<h5 id="虽然这种方式非常好用，但是一个最大的缺陷是，只能够实现get请求"><a href="#虽然这种方式非常好用，但是一个最大的缺陷是，只能够实现get请求" class="headerlink" title="虽然这种方式非常好用，但是一个最大的缺陷是，只能够实现get请求"></a>虽然这种方式非常好用，但是一个最大的缺陷是，只能够实现get请求</h5><h5 id="b-cors"><a href="#b-cors" class="headerlink" title="b. cors"></a>b. cors</h5><ul>
<li>简介<br>CORS是一个W3C标准，全称是”跨域资源共享”（Cross-origin resource sharing）。<br>它允许浏览器向跨源服务器，发出XMLHttpRequest请求，从而克服了AJAX只能同源使用的限制。</li>
</ul>
<p>CORS需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能，IE浏览器不能低于IE10。IE8+：IE8/9需要使用XDomainRequest对象来支持CORS。</p>
<p>整个CORS通信过程，都是浏览器自动完成，不需要用户参与。对于开发者来说，CORS通信与同源的AJAX通信没有差别，代码完全一样。浏览器一旦发现AJAX请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。<br>因此，实现CORS通信的关键是服务器。只要服务器实现了CORS接口，就可以跨源通信。</p>
<ul>
<li><p>两种请求（浏览器对这两种请求方式是不一样的）</p>
<ol>
<li><p>简单请求<br>请求方式为HEAD、POST 或者 GET<br>http头信息不超出一下字段：Accept、Accept-Language 、 Content-Language、 Last-Event-ID、 Content-Type(限于三个值：application/x-www-form-urlencoded、multipart/form-data、text/plain)</p>
</li>
<li><p>非简单请求<br>非简单请求是那种对服务器有特殊要求的请求，比如请求方法是PUT或DELETE，或者Content-Type字段的类型是application/json。<br>非简单请求的CORS请求，会在正式通信之前，增加一次HTTP查询请求，称为”预检”请求（preflight）。<br>浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些HTTP动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的XMLHttpRequest请求，否则就报错。</p>
</li>
</ol>
</li>
</ul>
  
	</div>
		<footer class="article-footer clearfix">




<div class="article-share" id="share">

  <div data-url="http://yoursite.com/2019/03/15/前端知识点总结（一）.html" data-title="前端知识点总结（一） | Welkin" data-tsina="null" class="share clearfix">
  </div>

</div>
</footer>   	       
	</article>
	
<nav class="article-nav clearfix">
 

<div class="next">
<a href="/2019/03/13/数据结构之排序.html"  title="数据结构之排序">
 <strong>NEXT:</strong><br/> 
 <span>数据结构之排序
</span>
</a>
</div>

</nav>

	
</div>  
      <div class="openaside"><a class="navbutton" href="#" title="Show Sidebar"></a></div>

  <div id="toc" class="toc-aside">
  <strong class="toc-title">Contents</strong>
  <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#一、ES6"><span class="toc-number">1.</span> <span class="toc-text">一、ES6</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-let-const-和var-的区别"><span class="toc-number">1.0.1.</span> <span class="toc-text">1. let const 和var 的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#a-let和const的区别"><span class="toc-number">1.0.1.0.1.</span> <span class="toc-text">a. let和const的区别</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#b-let和const和var-有三点区别"><span class="toc-number">1.0.1.0.2.</span> <span class="toc-text">b. let和const和var 有三点区别</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-promise"><span class="toc-number">1.0.2.</span> <span class="toc-text">2. promise</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#a-promise是什么？"><span class="toc-number">1.0.2.0.1.</span> <span class="toc-text">a. promise是什么？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#b-promise的特点"><span class="toc-number">1.0.2.0.2.</span> <span class="toc-text">b. promise的特点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#c-promise-的作用"><span class="toc-number">1.0.2.0.3.</span> <span class="toc-text">c. promise 的作用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#d-promise-的缺点、"><span class="toc-number">1.0.2.0.4.</span> <span class="toc-text">d. promise 的缺点、</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#如果某些事件不断的反复发生，使用stream-模式nodejs-org-api-stream-html，是比部署promise更好的选择"><span class="toc-number">1.0.2.0.4.1.</span> <span class="toc-text">如果某些事件不断的反复发生，使用stream 模式nodejs.org/api/stream.html，是比部署promise更好的选择</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#e-promise基本用法"><span class="toc-number">1.0.2.0.5.</span> <span class="toc-text">e. promise基本用法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#f-then方法指定resolved-和-rejected-状态的回调函数"><span class="toc-number">1.0.2.0.6.</span> <span class="toc-text">f. .then方法指定resolved 和 rejected 状态的回调函数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-箭头函数"><span class="toc-number">1.0.3.</span> <span class="toc-text">3. 箭头函数</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#箭头函数的缺点"><span class="toc-number">1.0.3.0.1.</span> <span class="toc-text">箭头函数的缺点</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#二、vue"><span class="toc-number">2.</span> <span class="toc-text">二、vue</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-计算属性"><span class="toc-number">2.0.1.</span> <span class="toc-text">1. 计算属性</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#a-为什么会有计算属性"><span class="toc-number">2.0.1.0.1.</span> <span class="toc-text">a. 为什么会有计算属性</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#b-如何使用计算属性"><span class="toc-number">2.0.1.0.2.</span> <span class="toc-text">b. 如何使用计算属性</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#c-计算属性缓存和方法（method）的对比"><span class="toc-number">2.0.1.0.3.</span> <span class="toc-text">c. 计算属性缓存和方法（method）的对比</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#每当触发重新渲染时，调用方法将总会再次执行函数。"><span class="toc-number">2.0.1.0.3.1.</span> <span class="toc-text">每当触发重新渲染时，调用方法将总会再次执行函数。</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#d-计算属性和侦听属性（watch）的对比"><span class="toc-number">2.0.1.0.4.</span> <span class="toc-text">d. 计算属性和侦听属性（watch）的对比</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#e-计算属性的setter"><span class="toc-number">2.0.1.0.5.</span> <span class="toc-text">e. 计算属性的setter</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-自定义指令"><span class="toc-number">2.0.2.</span> <span class="toc-text">2. 自定义指令</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#a-为什么会有自定义指令"><span class="toc-number">2.0.2.0.1.</span> <span class="toc-text">a. 为什么会有自定义指令</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#b-怎么使用自定义指令？"><span class="toc-number">2.0.2.0.2.</span> <span class="toc-text">b. 怎么使用自定义指令？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-父子组件"><span class="toc-number">2.0.3.</span> <span class="toc-text">3. 父子组件</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#a-父组件通过-Prop向子组件传递数据"><span class="toc-number">2.0.3.0.1.</span> <span class="toc-text">a. 父组件通过 Prop向子组件传递数据</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#b-子组件往父组件传值（-emit）"><span class="toc-number">2.0.3.0.2.</span> <span class="toc-text">b. 子组件往父组件传值（$emit）</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#三、http"><span class="toc-number">3.</span> <span class="toc-text">三、http</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-get和post在url协议上的区别"><span class="toc-number">3.0.1.</span> <span class="toc-text">1. get和post在url协议上的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-get请求和post请求的区别"><span class="toc-number">3.0.2.</span> <span class="toc-text">2. get请求和post请求的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-跨域"><span class="toc-number">3.0.3.</span> <span class="toc-text">3. 跨域</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-什么是跨域"><span class="toc-number">3.0.3.0.1.</span> <span class="toc-text">1. 什么是跨域</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-为什么会有跨域"><span class="toc-number">3.0.3.0.2.</span> <span class="toc-text">2. 为什么会有跨域</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-常见的跨域场景"><span class="toc-number">3.0.3.0.3.</span> <span class="toc-text">3. 常见的跨域场景</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-跨域的解决方案"><span class="toc-number">3.0.3.0.4.</span> <span class="toc-text">4. 跨域的解决方案</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#a-jsonp"><span class="toc-number">3.0.3.0.4.1.</span> <span class="toc-text">a. jsonp</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#虽然这种方式非常好用，但是一个最大的缺陷是，只能够实现get请求"><span class="toc-number">3.0.3.0.5.</span> <span class="toc-text">虽然这种方式非常好用，但是一个最大的缺陷是，只能够实现get请求</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#b-cors"><span class="toc-number">3.0.3.0.6.</span> <span class="toc-text">b. cors</span></a></li></ol></li></ol></li></ol></li></ol></li></ol>
  </div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="Hide Sidebar"></a></div>
<aside class="clearfix">

  

  

  <div class="rsspart">
	<a href="null" target="_blank" title="rss">RSS</a>
</div>

</aside>
</div>
    </div>
    <footer><div id="footer" >
	
	<div class="line">
		<span></span>
		<div class="author"></div>
	</div>
	
	
	<div class="social-font clearfix">
		
		
		
		
		
	</div>
		<p class="copyright">Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/A-limon/pacman" target="_blank" title="Pacman">Pacman</a> © 2019 
		
		<a href="http://yoursite.com" target="_blank" title="welkin">welkin</a>
		
		</p>
</div>
</footer>
    <script src="/js/jquery-2.1.0.min.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else
    {
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
      
      $('#toc.toc-aside').css('display', 'none');
        
    }
  });
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
});
</script>

<script type="text/javascript">
$(document).ready(function(){ 
  var ai = $('.article-content>iframe'),
      ae = $('.article-content>embed'),
      t  = $('#toc'),
      h  = $('article h2')
      ah = $('article h2'),
      ta = $('#toc.toc-aside'),
      o  = $('.openaside'),
      c  = $('.closeaside');
  if(ai.length>0){
    ai.wrap('<div class="video-container" />');
  };
  if(ae.length>0){
   ae.wrap('<div class="video-container" />');
  };
  if(ah.length==0){
    t.css('display','none');
  }else{
    c.click(function(){
      ta.css('display', 'block').addClass('fadeIn');
    });
    o.click(function(){
      ta.css('display', 'none');
    });
    $(window).scroll(function(){
      ta.css("top",Math.max(140,320-$(this).scrollTop()));
    });
  };
});
</script>


<script type="text/javascript">
$(document).ready(function(){ 
  var $this = $('.share'),
      url = $this.attr('data-url'),
      encodedUrl = encodeURIComponent(url),
      title = $this.attr('data-title'),
      tsina = $this.attr('data-tsina');
  var html = [
  '<a href="#" class="overlay" id="qrcode"></a>',
  '<div class="qrcode clearfix"><span>扫描二维码分享到微信朋友圈</span><a class="qrclose" href="#share"></a><strong>Loading...Please wait</strong><img id="qrcode-pic" data-src="http://s.jiathis.com/qrcode.php?url=' + encodedUrl + '"/></div>',
  '<a href="#textlogo" class="article-back-to-top" title="Top"></a>',
  '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="article-share-facebook" target="_blank" title="Facebook"></a>',
  '<a href="#qrcode" class="article-share-qrcode" title="QRcode"></a>',
  '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="article-share-twitter" target="_blank" title="Twitter"></a>',
  '<a href="http://service.weibo.com/share/share.php?title='+title+'&url='+encodedUrl +'&ralateUid='+ tsina +'&searchPic=true&style=number' +'" class="article-share-weibo" target="_blank" title="Weibo"></a>',
  '<span title="Share to"></span>'
  ].join('');
  $this.append(html);
  $('.article-share-qrcode').click(function(){
    var imgSrc = $('#qrcode-pic').attr('data-src');
    $('#qrcode-pic').attr('src', imgSrc);
    $('#qrcode-pic').load(function(){
        $('.qrcode strong').text(' ');
    });
  });
});     
</script>






  </body>
</html>
