
 <!DOCTYPE HTML>
<html lang="zh">
<head>
  <meta charset="UTF-8">
  
    <title>初识Node之Node中的js - 核心模块 | Welkin</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=3, minimum-scale=1">
    
    <meta name="author" content="welkin">
    
    <meta name="description" content="一、Nod.js基本概念1.为什么学Node-企业需求：具有服务端开发需求-目的：打开服务端黑匣子-网站开发能力：服务端，前端，运维部署
2.Node是什么？-Node.js不是语言，不是库，也不是框架-是JS运行时环境（是一个平台），可以解析和执行JS代码
##3. Node.js 中的 Java">
    
    
    
    
    
    <link rel="icon" href="/img/favicon.ico">
    
    
    <link rel="apple-touch-icon" href="/img/pacman.jpg">
    <link rel="apple-touch-icon-precomposed" href="/img/pacman.jpg">
    
    <link rel="stylesheet" href="/css/style.css">
</head>

  <body>
    <header>
      <div>
		
			<div id="imglogo">
				<a href="/"><img src="/img/logo.svg" alt="Welkin" title="Welkin"/></a>
			</div>
			
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="Welkin">Welkin</a></h1>
				<h2 class="blog-motto"></h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="Menu">
			</a></div>
			<nav class="animated">
				<ul>
					
						<li><a href="/">Home</a></li>
					
						<li><a href="/archives">Archives</a></li>
					
					<li>
					
					<form class="search" action="//google.com/search" method="get" accept-charset="utf-8">
						<label>Search</label>
						<input type="text" id="search" name="q" autocomplete="off" maxlength="20" placeholder="Search" />
						<input type="hidden" name="q" value="site:yoursite.com">
					</form>
					
					</li>
				</ul>
			</nav>			
</div>

    </header>
    <div id="container">
      <div id="main" class="post" itemscope itemprop="blogPost">
	<article itemprop="articleBody"> 
		<header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2018/09/19/初识Node之Node中的js-核心模块.html" title="初识Node之Node中的js - 核心模块" itemprop="url">初识Node之Node中的js - 核心模块</a>
  </h1>
  <p class="article-author">By
    
      <a href="http://yoursite.com" title="welkin">welkin</a>
    </p>
  <p class="article-time">
    <time datetime="2018-09-19T15:46:59.000Z" itemprop="datePublished">2018-09-19</time>
    Updated:<time datetime="2018-09-19T15:47:33.681Z" itemprop="dateModified">2018-09-19</time>
    
  </p>
</header>
	<div class="article-content">
		
		
		<div id="toc" class="toc-article">
			<strong class="toc-title">Contents</strong>
		<ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#一、Nod-js基本概念"><span class="toc-number">1.</span> <span class="toc-text">一、Nod.js基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-为什么学Node"><span class="toc-number">1.1.</span> <span class="toc-text">1.为什么学Node</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-Node是什么？"><span class="toc-number">1.2.</span> <span class="toc-text">2.Node是什么？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#二、基本Node操作"><span class="toc-number">2.</span> <span class="toc-text">二、基本Node操作</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-使用Node执行js脚本文件"><span class="toc-number">2.1.</span> <span class="toc-text">1.使用Node执行js脚本文件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#例1"><span class="toc-number">2.1.1.</span> <span class="toc-text">例1</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-Node的读文件基本操作"><span class="toc-number">2.2.</span> <span class="toc-text">2.Node的读文件基本操作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#a-使用-require-方法加载-fs-核心模块"><span class="toc-number">2.2.0.1.</span> <span class="toc-text">a.使用 require 方法加载 fs 核心模块</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-Node的写文件基本操作"><span class="toc-number">2.3.</span> <span class="toc-text">3.Node的写文件基本操作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#a-写文件的第一步也是使用require加载fs核心模块"><span class="toc-number">2.3.0.1.</span> <span class="toc-text">a.写文件的第一步也是使用require加载fs核心模块</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#三、Node之http服务"><span class="toc-number">3.</span> <span class="toc-text">三、Node之http服务</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-简单的http服务"><span class="toc-number">3.1.</span> <span class="toc-text">1.简单的http服务</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#a-加载-http-核心模块"><span class="toc-number">3.1.0.1.</span> <span class="toc-text">a.加载 http 核心模块</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#b-使用-http-createServer-方法创建一个-Web-服务器；返回一个-Server-实例"><span class="toc-number">3.1.0.2.</span> <span class="toc-text">b.使用 http.createServer() 方法创建一个 Web 服务器；返回一个 Server 实例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#c-注册-request-请求事件"><span class="toc-number">3.1.0.3.</span> <span class="toc-text">c.注册 request 请求事件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#d-绑定端口号，启动服务器"><span class="toc-number">3.1.0.4.</span> <span class="toc-text">d.绑定端口号，启动服务器</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-发送响应"><span class="toc-number">3.2.</span> <span class="toc-text">2.发送响应</span></a></li></ol></li></ol>
		</div>
		
		<h1 id="一、Nod-js基本概念"><a href="#一、Nod-js基本概念" class="headerlink" title="一、Nod.js基本概念"></a>一、Nod.js基本概念</h1><h2 id="1-为什么学Node"><a href="#1-为什么学Node" class="headerlink" title="1.为什么学Node"></a>1.为什么学Node</h2><p><code>-</code><strong>企业需求：</strong>具有服务端开发需求<br><code>-</code><strong>目的：</strong>打开服务端黑匣子<br><code>-</code><strong>网站开发能力：</strong>服务端，前端，运维部署</p>
<h2 id="2-Node是什么？"><a href="#2-Node是什么？" class="headerlink" title="2.Node是什么？"></a>2.Node是什么？</h2><p><code>-</code>Node.js不是语言，不是库，也不是框架<br><code>-</code>是JS运行时环境（是一个平台），可以解析和执行JS代码</p>
<p>##3. Node.js 中的 JavaScript</p>
<ul>
<li>没有 BOM、DOM</li>
<li>EcmaScript 基本的 JavaScript 语言部分</li>
<li>在 Node 中为 JavaScript 提供了一些服务器级别的 API<ul>
<li>文件操作的能力</li>
<li>http 服务的能力</li>
<li>网络服务构建的能力</li>
</ul>
</li>
<li>EcmaScript<ul>
<li>变量</li>
<li>方法</li>
<li>数据类型</li>
<li>内置对象</li>
<li>Array</li>
<li>Object</li>
<li>Date</li>
<li>Math<h1 id="二、基本Node操作"><a href="#二、基本Node操作" class="headerlink" title="二、基本Node操作"></a>二、基本Node操作</h1><h2 id="1-使用Node执行js脚本文件"><a href="#1-使用Node执行js脚本文件" class="headerlink" title="1.使用Node执行js脚本文件"></a>1.使用Node执行js脚本文件</h2><strong>注意</strong>：node文件名<strong>不要用node.js命名</strong>，<strong>不要使用中文</strong><h3 id="例1"><a href="#例1" class="headerlink" title="例1"></a>例1</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var foo = &apos;hello nodejs&apos;</span><br><span class="line">console.log(foo)</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<p>在终端或者cmd里中node + 文件名便可执行文件<br><img src="https://upload-images.jianshu.io/upload_images/2549157-f1888137b62bd243.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="结果"></p>
<p>（我这个文件的名字叫做Hello_wrold.js）<br>可以看出，node和js基本语法一样</p>
<p><hr></p>
<p>###例2<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.log(window)</span><br><span class="line">console.log(document)</span><br></pre></td></tr></table></figure></p>
<p>我们在node中执行js的一些操作，结果如下：<br><img src="https://upload-images.jianshu.io/upload_images/2549157-4a1c2857b634aca3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="结果"><br>没有任何输出，但是我们在html中打开浏览器界面，引用这个js文件在控制台可以看见<br><img src="https://upload-images.jianshu.io/upload_images/2549157-665e7f6f2575644c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="结果"><br><strong>注意：</strong>Node和浏览器中的 JavaScript 不一样</p>
<h2 id="2-Node的读文件基本操作"><a href="#2-Node的读文件基本操作" class="headerlink" title="2.Node的读文件基本操作"></a>2.Node的读文件基本操作</h2><p><strong>注意</strong>：<br><code>1.</code>浏览器中的 JavaScript 是没有文件操作的能力的，但是 Node 中的 JavaScript 具有文件操作的能力<br><code>2.</code>在 Node 中如果想要进行文件操作，就必须引入 fs 这个核心模块; 在 fs 这个核心模块中，就提供了所有的文件操作相关的 API<br><code>3.</code>fs 是 file-system 的简写，就是文件系统的意思；例如：fs.readFile 就是用来读取文件的</p>
<h4 id="a-使用-require-方法加载-fs-核心模块"><a href="#a-使用-require-方法加载-fs-核心模块" class="headerlink" title="a.使用 require 方法加载 fs 核心模块"></a>a.使用 require 方法加载 fs 核心模块</h4><blockquote>
<p>var fs = require(‘fs’)</p>
<p>####b.读取文件<br><strong>注意</strong>：<br><code>1.</code>第一个参数就是要读取的文件路径<br><code>2.</code>第二个参数是一个回调函数<br><code>3.</code>回调函数又有两个参数：error和data；如果读取路径成功，data返回数据，error返回null；反之，如果读取路径失败，data返回null，error返回错误对象</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fs.readFile(&apos;./data/hello.txt&apos;, function (error, data) &#123;</span><br><span class="line">  console.log(data)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>（我创建了一个名为data的文件夹，里面保存了一个名为hello.txt的文件，内容为：hello node）<br>结果如下：<img src="https://upload-images.jianshu.io/upload_images/2549157-cfe41a719ece5756.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br><strong>注意：</strong></p>
<blockquote>
<buffer 20="" 64="" 65="" 68="" 73="" 6c="" 6f="" 6e="" 6a="" 0d="" 0a="">


</buffer></blockquote>
<p>  文件中存储的其实都是二进制数据 0 1； 这里为什么看到的不是 0 和 1 呢？原因是二进制转为 16 进制了；但是无论是二进制01还是16进制，人类都不认识；所以我们可以通过 toString 方法把其转为我们能认识的字符<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var fs = require(&apos;fs&apos;)</span><br><span class="line">fs.readFile(&apos;./data/hello.txt&apos;, function (error, data) &#123;</span><br><span class="line">    //console.log(data)</span><br><span class="line">    console.log(data.toString())  //hello node</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p><hr><br><strong>在这里存在一个小问题：</strong><br>如果我们将路径写错了，看看上面写的代码会出现什么问题。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var fs = require(&apos;fs&apos;)</span><br><span class="line">fs.readFile(&apos;./data/a.txt&apos;, function (error, data) &#123;</span><br><span class="line">    console.log(data)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p><img src="https://upload-images.jianshu.io/upload_images/2549157-02a9ba99e0641f59.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="结果"><br>因为data里面是null，所以结果为undefined<br>在这里就可以通过判断 error 来确认是否有错误发生<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var fs = require(&apos;fs&apos;)</span><br><span class="line">fs.readFile(&apos;./data/a.txt&apos;, function (error, data) &#123;</span><br><span class="line">    //console.log(data)</span><br><span class="line">    //console.log(data.toString())</span><br><span class="line">    if (error) &#123;</span><br><span class="line">        console.log(&apos;读取文件失败了&apos;)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        console.log(data.toString())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>如果读取失败，结果如下图所示：<br><img src="https://upload-images.jianshu.io/upload_images/2549157-e318c832fb2c9f8b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="读取失败结果"></p>
<h2 id="3-Node的写文件基本操作"><a href="#3-Node的写文件基本操作" class="headerlink" title="3.Node的写文件基本操作"></a>3.Node的写文件基本操作</h2><h4 id="a-写文件的第一步也是使用require加载fs核心模块"><a href="#a-写文件的第一步也是使用require加载fs核心模块" class="headerlink" title="a.写文件的第一步也是使用require加载fs核心模块"></a>a.写文件的第一步也是使用require加载fs核心模块</h4><blockquote>
<p>var fs = require(‘fs’)</p>
</blockquote>
<p>####b.写入文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fs.writeFile(&apos;./data/你好.md&apos;, &apos;大家好，给大家介绍一下，我是Node.js&apos;, function (error) &#123;</span><br><span class="line">    console.log(&apos;文件写入成功&apos;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>结果会在控制台输出：文件写入成功<br>同时在data文件下新建你好.md文件，并把内容写入<br><img src="https://upload-images.jianshu.io/upload_images/2549157-2ee81beee9b74588.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="写文件操作"><br><strong>注意：</strong>writeFile有三个参数<br><code>1.</code>第一个参数：文件路径<br><code>2.</code>第二个参数：文件内容<br><code>3.</code>第三个参数：回调函数。回调函数在这里只有一个参数error；若文件写入成功，error 是 null；若文件写入失败，error 就是错误对象</p>
<p><hr><br><strong>注意：</strong><br><strong>在这里存在一个小问题：</strong><br>如果我们将路径写错了，看看上面写的代码会出现什么问题。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fs.writeFile(&apos;./d/你好.md&apos;, &apos;大家好，给大家介绍一下，我是Node.js&apos;, function (error) &#123;</span><br><span class="line">    console.log(&apos;文件写入成功&apos;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>我把data文件夹改成了d文件夹<br>结果如下：<img src="https://upload-images.jianshu.io/upload_images/2549157-c73e1485f328373c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="写入文件错误"><br>只是在控制台输出语句，但是在data文件夹里没有新建文件，也没有新建d文件夹。</p>
<p><hr><br>因此，我们可以在这里加上 if 语句进行判断<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fs.writeFile(&apos;./data/你好.md&apos;, &apos;大家好，给大家介绍一下，我是Node.js&apos;, function (error) &#123;</span><br><span class="line">  if (error) &#123;</span><br><span class="line">    console.log(&apos;写入失败&apos;)</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    console.log(&apos;写入成功了&apos;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<h1 id="三、Node之http服务"><a href="#三、Node之http服务" class="headerlink" title="三、Node之http服务"></a>三、Node之http服务</h1><h2 id="1-简单的http服务"><a href="#1-简单的http服务" class="headerlink" title="1.简单的http服务"></a>1.简单的http服务</h2><p>我们可以使用 Node 非常轻松的构建一个 Web 服务器；在 Node 中专门提供了一个核心模块：http；http 这个模块的职责就是帮你创建编写服务器的</p>
<h4 id="a-加载-http-核心模块"><a href="#a-加载-http-核心模块" class="headerlink" title="a.加载 http 核心模块"></a>a.加载 http 核心模块</h4><blockquote>
<p>var http = require(‘http’)</p>
<h4 id="b-使用-http-createServer-方法创建一个-Web-服务器；返回一个-Server-实例"><a href="#b-使用-http-createServer-方法创建一个-Web-服务器；返回一个-Server-实例" class="headerlink" title="b.使用 http.createServer() 方法创建一个 Web 服务器；返回一个 Server 实例"></a>b.使用 http.createServer() 方法创建一个 Web 服务器；返回一个 Server 实例</h4><p>var server = http.createServer()</p>
<h4 id="c-注册-request-请求事件"><a href="#c-注册-request-请求事件" class="headerlink" title="c.注册 request 请求事件"></a>c.注册 request 请求事件</h4><p>当客户端请求过来，就会自动触发服务器的 request 请求事件，然后执行第二个参数：回调处理函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">server.on(&apos;request&apos;, function () &#123;</span><br><span class="line">  console.log(&apos;收到客户端的请求了&apos;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h4 id="d-绑定端口号，启动服务器"><a href="#d-绑定端口号，启动服务器" class="headerlink" title="d.绑定端口号，启动服务器"></a>d.绑定端口号，启动服务器</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">server.listen(3000, function () &#123;</span><br><span class="line">  console.log(&apos;服务器启动成功了，可以通过 http://127.0.0.1:3000/ 来进行访问&apos;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>运行该JS文件后，就可以打开浏览器<br><strong>端口号范围：</strong>0~65536</p>
<h2 id="2-发送响应"><a href="#2-发送响应" class="headerlink" title="2.发送响应"></a>2.发送响应</h2><p><strong>request 请求事件处理函数，需要接收两个参数：</strong></p>
<ul>
<li>Request 请求对象<ul>
<li>请求对象可以用来获取客户端的一些请求信息，例如请求路径<ul>
<li>Response 响应对象</li>
</ul>
</li>
<li>响应对象可以用来给客户端发送响应消息</li>
</ul>
</li>
<li>response 对象有一个方法：write 可以用来给客户端发送响应数据<ul>
<li>write 可以使用多次，但是最后一定要使用 end 来结束响应，否则客户端会一直等待<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var http = require(&apos;http&apos;)</span><br><span class="line">var server = http.createServer()</span><br><span class="line"></span><br><span class="line">server.on(&apos;request&apos;, function (request, response) &#123;</span><br><span class="line">  console.log(&apos;收到客户端的请求了，请求路径是：&apos; + request.url)</span><br><span class="line"></span><br><span class="line">  response.write(&apos;hello&apos;)</span><br><span class="line">  response.write(&apos; nodejs&apos;)</span><br><span class="line">  response.end()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">server.listen(3000, function () &#123;</span><br><span class="line">  console.log(&apos;服务器启动成功了，可以通过 http://127.0.0.1:3000/ 来进行访问&apos;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<p>结果在浏览器输出：<br><img src="https://upload-images.jianshu.io/upload_images/2549157-6ba8b297851b0ddd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="浏览器输出"></p>
<p><hr></p>
<p>##3.练习：根据不同的请求路径返回不同数据<br><strong>注意：</strong><br>上面使用的 res.write方式比较麻烦，推荐使用更简单的方式，直接 end 的同时发送响应数据<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// res.write(&apos;hello&apos;)</span><br><span class="line">// res.write(&apos; world&apos;)</span><br><span class="line">// res.end()</span><br><span class="line">res.end(&apos;hello nodejs&apos;)</span><br></pre></td></tr></table></figure></p>
<p>####练习分析：根据不同的请求路径发送不同的响应结果<br> <code>-</code> <strong>1. 获取请求路径</strong><br> <code>+</code>req.url 获取到的是端口号之后的那一部分路径<br>   ·<code>+</code> url：同一资源定位符，一个url其实是要定一个资源<br> <code>+</code>也就是说所有的 url 都是以 / 开头的<br><code>-</code> <strong>2. 判断路径处理响应</strong><br> <code>+</code>响应内容只能是二进制数据或者字符串、数字、对象、数组、布尔值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">var http = require(&apos;http&apos;)</span><br><span class="line">var server = http.createServer()</span><br><span class="line">server.on(&apos;request&apos;, function (req, res) &#123;</span><br><span class="line">  console.log(&apos;收到请求了，请求路径是：&apos; + req.url)</span><br><span class="line">  console.log(&apos;请求我的客户端的地址是：&apos;, req.socket.remoteAddress, req.socket.remotePort)</span><br><span class="line">  var url = req.url</span><br><span class="line"></span><br><span class="line">  if (url === &apos;/&apos;) &#123;</span><br><span class="line">    res.end(&apos;index page&apos;)</span><br><span class="line">  &#125; else if (url === &apos;/login&apos;) &#123;</span><br><span class="line">    res.end(&apos;login page&apos;)</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    res.end(&apos;404 Not Found.&apos;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">server.listen(3000, function () &#123;</span><br><span class="line">  console.log(&apos;服务器启动成功，可以访问了。。。&apos;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>#4.端口号<br> <strong>ip 地址定位计算机</strong><br> <strong>端口号定位具体的应用程序</strong><br><strong>所有需要联网通信的应用程序都会占用一个端口号</strong><br>在cmd中输入</p>
<blockquote>
<p>ipconfig</p>
</blockquote>
<p>可以查看本机的端口号<br>在同一局域网的计算机可以访问自己的计算机<br><strong>req.socket.remoteAddress</strong>：当前请求我的计算机客户端的地址（ip地址和端口号）<br><strong>req.socket.remotePort</strong>：当前请求我的计算机客户端的端口号</p>
<p><hr><br>根据下列代码可以看见访问自己计算机的ip地址和端口号<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var http = require(&apos;http&apos;)</span><br><span class="line"></span><br><span class="line">var server = http.createServer()</span><br><span class="line"></span><br><span class="line">server.on(&apos;request&apos;, function (req, res) &#123;</span><br><span class="line">  console.log(&apos;收到请求了，请求路径是：&apos; + req.url)</span><br><span class="line">  console.log(&apos;请求我的客户端的地址是：&apos;, req.socket.remoteAddress, req.socket.remotePort)</span><br><span class="line"></span><br><span class="line">  res.end(&apos;hello nodejs&apos;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">server.listen(5000, function () &#123;</span><br><span class="line">  console.log(&apos;服务器启动成功，可以访问了。。。&apos;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>##5.Content-Type</p>
<ul>
<li>服务器最好把每次响应的数据是什么内容类型都告诉客户端，而且要正确的告诉</li>
<li>不同的资源对应的 Content-Type 是不一样，具体参照：<a href="http://tool.oschina.net/commons" target="_blank" rel="noopener">http://tool.oschina.net/commons</a><ul>
<li>对于文本类型的数据，最好都加上编码，目的是为了防止中文解析乱码问题<br><hr><br>####a.在浏览器中输出汉字<br>在之前的学习中，如果我们在res.end中写入中文的话，打开浏览器会出现乱码的情况；<br>其实在服务端默认发送的数据，其实是 utf8 编码的内容；但是浏览器不知道你是 utf8 编码的内容；浏览器在不知道服务器响应内容的编码的情况下会按照当前操作系统的默认编码去解析；中文操作系统默认是 gbk<br><strong>解决办法：</strong> 就是正确的告诉浏览器我给你发送的内容是什么编码的；在 http 协议中，Content-Type 就是用来告知对方我给你发送的数据内容是什么类型<blockquote>
<p>res.setHeader(‘Content-Type’, ‘text/plain; charset=utf-8’)</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<p>再输出res.end语句结果就正确了<br><strong>text/plain 就是普通文本</strong></p>
<p>####b.在浏览器中输出html标签<br>如果你发送的是 html 格式的字符串，则也要告诉浏览器我给你发送是 text/html 格式的内容<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">res.setHeader(&apos;Content-Type&apos;, &apos;text/html; charset=utf-8&apos;)</span><br><span class="line">res.end(&apos;&lt;p&gt;hello html &lt;a href=&quot;&quot;&gt;点我&lt;/a&gt;&lt;/p&gt;&apos;)</span><br></pre></td></tr></table></figure></p>
<p>结果会在浏览器中渲染成html标签</p>
<p><hr><br>利用文件的方法，将html文件渲染成页面<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fs.readFile(&apos;./resource/index.html&apos;, function (err, data) &#123;</span><br><span class="line">      if (err) &#123;</span><br><span class="line">        res.setHeader(&apos;Content-Type&apos;, &apos;text/plain; charset=utf-8&apos;)</span><br><span class="line">        res.end(&apos;文件读取失败，请稍后重试！&apos;)</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        res.setHeader(&apos;Content-Type&apos;, &apos;text/html; charset=utf-8&apos;)</span><br><span class="line">        res.end(data)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure></p>
<p>####c.在浏览器中输出图片<br><code>-</code>发送的并不是文件，本质上来讲发送是文件的内容<br><code>-</code>当浏览器收到服务器响应内容之后，就会根据你的 Content-Type 进行对应的解析处理；图片不需要指定编码；一般只为字符数据才指定编码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fs.readFile(&apos;./resource/ab2.jpg&apos;, function (err, data) &#123;</span><br><span class="line">     if (err) &#123;</span><br><span class="line">       res.setHeader(&apos;Content-Type&apos;, &apos;text/plain; charset=utf-8&apos;)</span><br><span class="line">       res.end(&apos;文件读取失败，请稍后重试！&apos;)</span><br><span class="line">     &#125; else &#123;</span><br><span class="line">       res.setHeader(&apos;Content-Type&apos;, &apos;image/jpeg&apos;)</span><br><span class="line">       res.end(data)</span><br><span class="line">     &#125;</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure></p>
<p>#四、Node中的js-模块系统<br>在 Node 中没有全局作用域的概念；在 Node 中，只能通过 require 方法来加载执行多个 JavaScript 脚本文件</p>
<p>##1.Node.js中的核心模块</p>
<ul>
<li>核心模块是由 Node 提供的一个个的具名的模块，它们都有自己特殊的名称标识，例如<pre><code>- fs 文件操作模块
- http 网络服务构建模块
- os 操作系统信息模块
- path 路径处理模块
</code></pre><ul>
<li>所有核心模块在使用的时候都必须手动的先使用 <code>require</code> 方法来加载，然后才可以使用，例如：<ul>
<li><code>var fs = require(&#39;fs&#39;)</code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 用来获取机器信息的</span><br><span class="line">var os = require(&apos;os&apos;)</span><br><span class="line"></span><br><span class="line">// 用来操作路径的</span><br><span class="line">var path = require(&apos;path&apos;)</span><br><span class="line"></span><br><span class="line">// 获取当前机器的 CPU 信息</span><br><span class="line">console.log(os.cpus())</span><br><span class="line"></span><br><span class="line">// memory 内存</span><br><span class="line">console.log(os.totalmem())</span><br><span class="line"></span><br><span class="line">// 获取一个路径中的扩展名部分</span><br><span class="line">// extname extension name</span><br><span class="line">console.log(path.extname(&apos;c:/a/b/c/d/hello.txt&apos;))</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>##2.Node.js中的模块系统</p>
<ul>
<li>在 Node 中没有全局作用域的概念<ul>
<li>在 Node 中，只能通过 require 方法来加载执行多个 JavaScript 脚本文件</li>
<li>require 加载只能是执行其中的代码，文件与文件之间由于是模块作用域，所以不会有污染的问题<ul>
<li>模块完全是封闭的</li>
<li>外部无法访问内部</li>
<li>内部也无法访问外部</li>
</ul>
</li>
<li>模块作用域固然带来了一些好处，可以加载执行多个文件，可以完全避免变量命名冲突污染的问题</li>
<li>但是某些情况下，模块与模块是需要进行通信的</li>
<li>在每个模块中，都提供了一个对象：<code>exports</code></li>
<li>该对象默认是一个空对象</li>
<li>你要做的就是把需要被外部访问使用的成员手动的挂载到 <code>exports</code> 接口对象中</li>
<li>然后谁来 <code>require</code> 这个模块，谁就可以得到模块内部的 <code>exports</code> 接口对象</li>
<li>还有其它的一些规则，具体后面讲，以及如何在项目中去使用这种编程方式，会通过后面的案例来处理</li>
</ul>
</li>
</ul>
  
	</div>
		<footer class="article-footer clearfix">




<div class="article-share" id="share">

  <div data-url="http://yoursite.com/2018/09/19/初识Node之Node中的js-核心模块.html" data-title="初识Node之Node中的js - 核心模块 | Welkin" data-tsina="null" class="share clearfix">
  </div>

</div>
</footer>   	       
	</article>
	
<nav class="article-nav clearfix">
 

<div class="next">
<a href="/2018/09/06/Promise的基础用法.html"  title="Promise的基础用法">
 <strong>NEXT:</strong><br/> 
 <span>Promise的基础用法
</span>
</a>
</div>

</nav>

	
</div>  
      <div class="openaside"><a class="navbutton" href="#" title="Show Sidebar"></a></div>

  <div id="toc" class="toc-aside">
  <strong class="toc-title">Contents</strong>
  <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#一、Nod-js基本概念"><span class="toc-number">1.</span> <span class="toc-text">一、Nod.js基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-为什么学Node"><span class="toc-number">1.1.</span> <span class="toc-text">1.为什么学Node</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-Node是什么？"><span class="toc-number">1.2.</span> <span class="toc-text">2.Node是什么？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#二、基本Node操作"><span class="toc-number">2.</span> <span class="toc-text">二、基本Node操作</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-使用Node执行js脚本文件"><span class="toc-number">2.1.</span> <span class="toc-text">1.使用Node执行js脚本文件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#例1"><span class="toc-number">2.1.1.</span> <span class="toc-text">例1</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-Node的读文件基本操作"><span class="toc-number">2.2.</span> <span class="toc-text">2.Node的读文件基本操作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#a-使用-require-方法加载-fs-核心模块"><span class="toc-number">2.2.0.1.</span> <span class="toc-text">a.使用 require 方法加载 fs 核心模块</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-Node的写文件基本操作"><span class="toc-number">2.3.</span> <span class="toc-text">3.Node的写文件基本操作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#a-写文件的第一步也是使用require加载fs核心模块"><span class="toc-number">2.3.0.1.</span> <span class="toc-text">a.写文件的第一步也是使用require加载fs核心模块</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#三、Node之http服务"><span class="toc-number">3.</span> <span class="toc-text">三、Node之http服务</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-简单的http服务"><span class="toc-number">3.1.</span> <span class="toc-text">1.简单的http服务</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#a-加载-http-核心模块"><span class="toc-number">3.1.0.1.</span> <span class="toc-text">a.加载 http 核心模块</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#b-使用-http-createServer-方法创建一个-Web-服务器；返回一个-Server-实例"><span class="toc-number">3.1.0.2.</span> <span class="toc-text">b.使用 http.createServer() 方法创建一个 Web 服务器；返回一个 Server 实例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#c-注册-request-请求事件"><span class="toc-number">3.1.0.3.</span> <span class="toc-text">c.注册 request 请求事件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#d-绑定端口号，启动服务器"><span class="toc-number">3.1.0.4.</span> <span class="toc-text">d.绑定端口号，启动服务器</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-发送响应"><span class="toc-number">3.2.</span> <span class="toc-text">2.发送响应</span></a></li></ol></li></ol>
  </div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="Hide Sidebar"></a></div>
<aside class="clearfix">

  

  

  <div class="rsspart">
	<a href="null" target="_blank" title="rss">RSS</a>
</div>

</aside>
</div>
    </div>
    <footer><div id="footer" >
	
	<div class="line">
		<span></span>
		<div class="author"></div>
	</div>
	
	
	<div class="social-font clearfix">
		
		
		
		
		
	</div>
		<p class="copyright">Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/A-limon/pacman" target="_blank" title="Pacman">Pacman</a> © 2018 
		
		<a href="http://yoursite.com" target="_blank" title="welkin">welkin</a>
		
		</p>
</div>
</footer>
    <script src="/js/jquery-2.1.0.min.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else
    {
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
      
      $('#toc.toc-aside').css('display', 'none');
        
    }
  });
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
});
</script>

<script type="text/javascript">
$(document).ready(function(){ 
  var ai = $('.article-content>iframe'),
      ae = $('.article-content>embed'),
      t  = $('#toc'),
      h  = $('article h2')
      ah = $('article h2'),
      ta = $('#toc.toc-aside'),
      o  = $('.openaside'),
      c  = $('.closeaside');
  if(ai.length>0){
    ai.wrap('<div class="video-container" />');
  };
  if(ae.length>0){
   ae.wrap('<div class="video-container" />');
  };
  if(ah.length==0){
    t.css('display','none');
  }else{
    c.click(function(){
      ta.css('display', 'block').addClass('fadeIn');
    });
    o.click(function(){
      ta.css('display', 'none');
    });
    $(window).scroll(function(){
      ta.css("top",Math.max(140,320-$(this).scrollTop()));
    });
  };
});
</script>


<script type="text/javascript">
$(document).ready(function(){ 
  var $this = $('.share'),
      url = $this.attr('data-url'),
      encodedUrl = encodeURIComponent(url),
      title = $this.attr('data-title'),
      tsina = $this.attr('data-tsina');
  var html = [
  '<a href="#" class="overlay" id="qrcode"></a>',
  '<div class="qrcode clearfix"><span>扫描二维码分享到微信朋友圈</span><a class="qrclose" href="#share"></a><strong>Loading...Please wait</strong><img id="qrcode-pic" data-src="http://s.jiathis.com/qrcode.php?url=' + encodedUrl + '"/></div>',
  '<a href="#textlogo" class="article-back-to-top" title="Top"></a>',
  '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="article-share-facebook" target="_blank" title="Facebook"></a>',
  '<a href="#qrcode" class="article-share-qrcode" title="QRcode"></a>',
  '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="article-share-twitter" target="_blank" title="Twitter"></a>',
  '<a href="http://service.weibo.com/share/share.php?title='+title+'&url='+encodedUrl +'&ralateUid='+ tsina +'&searchPic=true&style=number' +'" class="article-share-weibo" target="_blank" title="Weibo"></a>',
  '<span title="Share to"></span>'
  ].join('');
  $this.append(html);
  $('.article-share-qrcode').click(function(){
    var imgSrc = $('#qrcode-pic').attr('data-src');
    $('#qrcode-pic').attr('src', imgSrc);
    $('#qrcode-pic').load(function(){
        $('.qrcode strong').text(' ');
    });
  });
});     
</script>






  </body>
</html>
